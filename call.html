<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Firebase WebRTC Video Call</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1a2a6c, #2c3e50, #4a6491);
      color: #fff;
      line-height: 1.6;
      padding: 20px;
      min-height: 100vh;
    }
    
    .container {
      max-width: 1000px;
      margin: 0 auto;
      background: rgba(255, 255, 255, 0.12);
      border-radius: 20px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      padding: 25px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.15);
    }
    
    header {
      text-align: center;
      margin-bottom: 25px;
      padding-bottom: 15px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    h1 {
      font-size: 2.5rem;
      margin-bottom: 10px;
      text-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
      background: linear-gradient(to right, #4facfe, #00f2fe);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      letter-spacing: 1px;
    }
    
    .subtitle {
      color: #e0e0ff;
      font-size: 1.1rem;
      margin-top: 8px;
    }
    
    .user-info {
      background: rgba(0, 20, 40, 0.7);
      border-radius: 15px;
      padding: 15px;
      margin: 15px 0;
      text-align: center;
      border: 1px solid rgba(100, 180, 255, 0.3);
    }
    
    .user-info strong {
      color: #4facfe;
      font-size: 1.2rem;
    }
    
    .videos-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 25px;
      margin: 25px 0;
    }
    
    @media (min-width: 768px) {
      .videos-container {
        flex-direction: row;
        justify-content: space-around;
      }
    }
    
    .video-wrapper {
      position: relative;
      border-radius: 15px;
      overflow: hidden;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
      background: #000;
      width: 100%;
      max-width: 400px;
      transition: all 0.3s ease;
    }
    
    .video-wrapper.local {
      border: 3px solid #4facfe;
    }
    
    .video-wrapper.remote {
      border: 3px solid #00f2fe;
    }
    
    .video-label {
      position: absolute;
      bottom: 10px;
      left: 0;
      right: 0;
      text-align: center;
      background: rgba(0, 0, 0, 0.6);
      color: white;
      padding: 5px;
      font-weight: bold;
      border-radius: 0 0 10px 10px;
      z-index: 10;
    }
    
    video {
      width: 100%;
      display: block;
      background: #000;
      border-radius: 12px;
    }
    
    .controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 12px;
      margin: 25px 0;
      padding: 15px;
      background: rgba(0, 20, 45, 0.7);
      border-radius: 20px;
      border: 1px solid rgba(100, 180, 255, 0.2);
    }
    
    button {
      background: linear-gradient(to right, #4facfe, #00f2fe);
      color: white;
      border: none;
      padding: 12px 25px;
      font-size: 1rem;
      border-radius: 50px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-weight: 600;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.25);
      display: flex;
      align-items: center;
      gap: 8px;
      min-width: 140px;
      justify-content: center;
    }
    
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 15px rgba(0, 0, 0, 0.35);
    }
    
    button:active {
      transform: translateY(1px);
    }
    
    button#startBtn {
      background: linear-gradient(to right, #00c853, #00e676);
    }
    
    button#createBtn {
      background: linear-gradient(to right, #ffab00, #ffd149);
    }
    
    button#answerBtn {
      background: linear-gradient(to right, #00c853, #00e676);
      display: none;
    }
    
    button#hangupBtn {
      background: linear-gradient(to right, #ff1744, #ff5252);
      display: none;
    }
    
    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }
    
    .call-id-container {
      display: flex;
      gap: 10px;
      margin: 15px 0;
      justify-content: center;
      flex-wrap: wrap;
    }
    
    #callInput {
      padding: 12px 15px;
      border-radius: 50px;
      border: 2px solid rgba(255, 255, 255, 0.2);
      background: rgba(0, 20, 45, 0.8);
      color: white;
      font-size: 1rem;
      width: 250px;
      text-align: center;
      transition: all 0.3s;
    }
    
    #callInput:focus {
      outline: none;
      border-color: #4facfe;
      box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.3);
    }
    
    .status-bar {
      background: rgba(0, 25, 50, 0.85);
      border-radius: 15px;
      padding: 15px;
      margin: 20px 0;
      text-align: center;
      min-height: 30px;
      border: 1px solid rgba(100, 180, 255, 0.2);
      font-weight: 500;
    }
    
    .status-bar.calling {
      background: rgba(255, 165, 0, 0.15);
      color: #ffd149;
      animation: pulse 2s infinite;
    }
    
    .status-bar.connected {
      background: rgba(0, 200, 83, 0.15);
      color: #00e676;
    }
    
    .status-bar.ringing {
      background: rgba(255, 235, 59, 0.2);
      color: #ffeb3b;
      animation: pulse 1.5s infinite;
      box-shadow: 0 0 15px rgba(255, 235, 59, 0.5);
    }
    
    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.4); }
      70% { box-shadow: 0 0 0 10px rgba(255, 255, 255, 0); }
      100% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0); }
    }
    
    .incoming-call {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 15, 35, 0.92);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      display: none;
      animation: fadeIn 0.3s;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    .incoming-call-content {
      background: rgba(25, 45, 85, 0.95);
      border-radius: 25px;
      padding: 40px;
      text-align: center;
      box-shadow: 0 10px 50px rgba(0, 0, 0, 0.6);
      border: 2px solid #ffeb3b;
      max-width: 90%;
      width: 500px;
      animation: ring 2s ease-in-out infinite;
    }
    
    @keyframes ring {
      0% { transform: scale(1); }
      10% { transform: scale(1.03); }
      20% { transform: scale(0.97); }
      30% { transform: scale(1.02); }
      40% { transform: scale(0.98); }
      50% { transform: scale(1.01); }
      60% { transform: scale(0.99); }
      70% { transform: scale(1); }
      100% { transform: scale(1); }
    }
    
    .incoming-call h2 {
      font-size: 2.2rem;
      margin-bottom: 15px;
      color: #ffeb3b;
      text-shadow: 0 0 10px rgba(255, 235, 59, 0.7);
    }
    
    .caller-name {
      font-size: 2.8rem;
      font-weight: bold;
      margin: 15px 0;
      color: #4facfe;
      text-shadow: 0 0 15px rgba(79, 172, 254, 0.7);
    }
    
    .call-actions {
      display: flex;
      justify-content: center;
      gap: 25px;
      margin-top: 30px;
    }
    
    .call-actions button {
      padding: 15px 40px;
      font-size: 1.3rem;
      min-width: 180px;
      border-radius: 60px;
    }
    
    button#rejectBtn {
      background: linear-gradient(to right, #ff1744, #ff5252);
    }
    
    button#acceptBtn {
      background: linear-gradient(to right, #00c853, #00e676);
    }
    
    .call-id-display {
      background: rgba(0, 25, 60, 0.8);
      border-radius: 15px;
      padding: 12px 25px;
      margin: 15px 0;
      font-family: monospace;
      font-size: 1.3rem;
      letter-spacing: 2px;
      text-align: center;
      border: 1px dashed #4facfe;
      word-break: break-all;
      max-width: 100%;
    }
    
    .instructions {
      background: rgba(0, 30, 60, 0.7);
      border-radius: 15px;
      padding: 20px;
      margin-top: 20px;
      line-height: 1.7;
      border: 1px solid rgba(100, 180, 255, 0.2);
    }
    
    .instructions h3 {
      color: #4facfe;
      margin-bottom: 10px;
      text-align: center;
    }
    
    .instructions ol {
      padding-left: 20px;
      margin-top: 10px;
    }
    
    .instructions li {
      margin-bottom: 8px;
    }
    
    .hidden {
      display: none;
    }
    
    footer {
      text-align: center;
      margin-top: 25px;
      color: rgba(255, 255, 255, 0.6);
      font-size: 0.9rem;
      padding-top: 15px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    @media (max-width: 480px) {
      .container {
        padding: 15px;
      }
      
      h1 {
        font-size: 2rem;
      }
      
      .controls {
        flex-direction: column;
        align-items: center;
      }
      
      button {
        width: 100%;
        max-width: 300px;
      }
      
      .call-id-container {
        flex-direction: column;
        align-items: center;
      }
      
      #callInput {
        width: 100%;
        max-width: 300px;
      }
      
      .incoming-call-content {
        padding: 25px 20px;
        width: 90%;
      }
      
      .caller-name {
        font-size: 2.2rem;
      }
      
      .call-actions button {
        width: 100%;
        max-width: 250px;
        padding: 12px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>âœ¨ Video Calling System</h1>
      <div class="subtitle">Real-time communication with WebRTC & Firebase</div>
    </header>
    
    <div class="user-info">
      <div>Your Username: <strong id="usernameDisplay">Loading...</strong></div>
    </div>
    
    <div class="videos-container">
      <div class="video-wrapper local">
        <video id="localVideo" autoplay muted playsinline></video>
        <div class="video-label">Your Camera</div>
      </div>
      <div class="video-wrapper remote">
        <video id="remoteVideo" autoplay playsinline></video>
        <div class="video-label" id="remoteLabel">Remote User</div>
      </div>
    </div>
    
    <div class="status-bar" id="statusBar">Waiting for action...</div>
    
    <div class="controls">
      <button id="startBtn">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polygon points="10 8 16 12 10 16 10 8"></polygon></svg>
        Start Camera
      </button>
      <button id="createBtn">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
        Create Call
      </button>
      
      <div class="call-id-container">
        <input type="text" id="callInput" placeholder="Enter Call ID" maxlength="20">
        <button id="copyBtn">
          <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
          Copy ID
        </button>
      </div>
      
      <button id="answerBtn">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path></svg>
        Answer Call
      </button>
      <button id="hangupBtn">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path></svg>
        Hang Up
      </button>
    </div>
    
    <div class="call-id-display hidden" id="callIdDisplay"></div>
    
    <div class="instructions">
      <h3>How to Use</h3>
      <ol>
        <li>Click "Start Camera" to enable your webcam and microphone</li>
        <li>Click "Create Call" to generate a unique Call ID</li>
        <li>Share the Call ID with the person you want to call</li>
        <li>They enter the ID and click "Answer Call" to connect</li>
        <li>Click "Hang Up" to end the call</li>
      </ol>
    </div>
    
    <footer>
      <p>WebRTC Video Calling System â€¢ Firebase Realtime Communication</p>
    </footer>
  </div>
  
  <div class="incoming-call" id="incomingCall">
    <div class="incoming-call-content">
      <h2>ðŸ“ž Incoming Video Call</h2>
      <div class="caller-name" id="callerName">Loading...</div>
      <div>Would you like to accept this call?</div>
      <div class="call-actions">
        <button id="rejectBtn">
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
          Reject
        </button>
        <button id="acceptBtn">
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path></svg>
          Accept
        </button>
      </div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import { 
      getFirestore, collection, doc, setDoc, getDoc, updateDoc, 
      onSnapshot, addDoc, query, where, orderBy, limit 
    } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

    /* ðŸ”¥ REPLACE WITH YOUR FIREBASE CONFIG */
    const firebaseConfig = {
      apiKey: "YOUR_API_KEY",
      authDomain: "YOUR_AUTH_DOMAIN",
      projectId: "YOUR_PROJECT_ID",
    };

    // Initialize Firebase
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    /* WebRTC Setup */
    const servers = {
      iceServers: [
        { urls: "stun:stun.l.google.com:19302" },
        { urls: "stun:stun1.l.google.com:19302" }
      ]
    };

    let pc = new RTCPeerConnection(servers);
    let localStream = null;
    let remoteStream = new MediaStream();
    let currentCallId = null;
    let isCaller = false;
    let ringtone = null;

    // DOM Elements
    const localVideo = document.getElementById("localVideo");
    const remoteVideo = document.getElementById("remoteVideo");
    const remoteLabel = document.getElementById("remoteLabel");
    const startBtn = document.getElementById("startBtn");
    const createBtn = document.getElementById("createBtn");
    const answerBtn = document.getElementById("answerBtn");
    const hangupBtn = document.getElementById("hangupBtn");
    const callInput = document.getElementById("callInput");
    const copyBtn = document.getElementById("copyBtn");
    const statusBar = document.getElementById("statusBar");
    const callIdDisplay = document.getElementById("callIdDisplay");
    const usernameDisplay = document.getElementById("usernameDisplay");
    const incomingCall = document.getElementById("incomingCall");
    const callerName = document.getElementById("callerName");
    const acceptBtn = document.getElementById("acceptBtn");
    const rejectBtn = document.getElementById("rejectBtn");

    // Initialize username
    let username = localStorage.getItem('videoCallUsername');
    if (!username) {
      username = prompt('Enter your username for video calls:', 'User' + Math.floor(Math.random() * 1000));
      if (username && username.trim() !== '') {
        username = username.trim();
        localStorage.setItem('videoCallUsername', username);
      } else {
        username = 'Guest' + Math.floor(Math.random() * 1000);
        localStorage.setItem('videoCallUsername', username);
      }
    }
    usernameDisplay.textContent = username;
    
    // Set up ringtone
    ringtone = new Audio('https://assets.mixkit.co/sfx/preview/mixkit-classic-ringtone-1444.mp3');
    ringtone.loop = true;
    ringtone.volume = 0.3;

    // Set remote video stream
    remoteVideo.srcObject = remoteStream;

    // Handle incoming tracks
    pc.ontrack = event => {
      event.streams[0].getTracks().forEach(track => {
        if (!remoteStream.getTrackById(track.id)) {
          remoteStream.addTrack(track);
        }
      });
      updateStatus("Connected! Video call in progress...", "connected");
      hangupBtn.style.display = "flex";
      answerBtn.style.display = "none";
      createBtn.disabled = true;
      startBtn.disabled = true;
    };

    // Handle ICE candidates
    pc.onicecandidate = event => {
      // This will be set dynamically in create/answer functions
    };

    // Handle connection state changes
    pc.onconnectionstatechange = () => {
      console.log("Connection state:", pc.connectionState);
      if (pc.connectionState === "connected") {
        updateStatus("Connected! Video call in progress...", "connected");
      } else if (pc.connectionState === "disconnected" || pc.connectionState === "failed") {
        if (pc.connectionState === "failed") {
          pc.restartIce();
        }
        resetCall();
      }
    };

    // Start Camera
    startBtn.onclick = async () => {
      try {
        updateStatus("Starting camera...", "");
        localStream = await navigator.mediaDevices.getUserMedia({
          video: { width: { ideal: 1280 }, height: { ideal: 720 } },
          audio: true
        });

        localVideo.srcObject = localStream;
        localStream.getTracks().forEach(track => {
          pc.addTrack(track, localStream);
        });
        
        startBtn.disabled = true;
        createBtn.disabled = false;
        answerBtn.disabled = false;
        updateStatus("Camera ready! Create a call or answer an incoming call.", "");
      } catch (error) {
        console.error("Error accessing media devices:", error);
        updateStatus("Error accessing camera/microphone: " + error.message, "");
        alert("Error accessing camera/microphone. Please check permissions and try again.");
      }
    };

    // Create Call
    createBtn.onclick = async () => {
      if (!localStream) {
        alert("Please start your camera first!");
        return;
      }
      
      isCaller = true;
      currentCallId = 'call-' + Math.random().toString(36).substr(2, 9);
      
      const callDoc = doc(collection(db, "calls"), currentCallId);
      const offerCandidates = collection(callDoc, "offerCandidates");
      const answerCandidates = collection(callDoc, "answerCandidates");

      callInput.value = currentCallId;
      callIdDisplay.textContent = currentCallId;
      callIdDisplay.classList.remove("hidden");
      
      // Set up ICE candidate handling
      pc.onicecandidate = event => {
        if (event.candidate) {
          addDoc(offerCandidates, event.candidate.toJSON());
        }
      };

      // Create offer
      try {
        updateStatus("Creating offer...", "calling");
        const offerDescription = await pc.createOffer();
        await pc.setLocalDescription(offerDescription);

        // Save offer and caller info to Firestore
        await setDoc(callDoc, {
          offer: {
            type: offerDescription.type,
            sdp: offerDescription.sdp,
          },
          caller: username,
          callee: null,
          createdAt: new Date().toISOString()
        });

        // Listen for answer and callee info
        onSnapshot(callDoc, snapshot => {
          const data = snapshot.data();
          if (!pc.currentRemoteDescription && data?.answer) {
            const answerDescription = new RTCSessionDescription(data.answer);
            pc.setRemoteDescription(answerDescription);
          }
          
          // Update if callee has answered
          if (data?.callee && remoteLabel.textContent === "Remote User") {
            remoteLabel.textContent = data.callee;
            updateStatus(`Connected with ${data.callee}!`, "connected");
          }
        });

        // Listen for ICE candidates from answerer
        onSnapshot(answerCandidates, snapshot => {
          snapshot.docChanges().forEach(change => {
            if (change.type === "added") {
              const candidate = new RTCIceCandidate(change.doc.data());
              pc.addIceCandidate(candidate);
            }
          });
        });
        
        updateStatus(`Call created! Share this ID with your contact: ${currentCallId}`, "calling");
        createBtn.disabled = true;
        answerBtn.disabled = true;
      } catch (error) {
        console.error("Error creating call:", error);
        updateStatus("Error creating call: " + error.message, "");
        resetCall();
      }
    };

    // Answer Call
    answerBtn.onclick = async () => {
      const callId = callInput.value.trim();
      if (!callId) {
        alert("Please enter a Call ID!");
        return;
      }
      
      if (!localStream) {
        alert("Please start your camera first!");
        return;
      }
      
      await handleAnswerCall(callId);
    };

    // Copy Call ID
    copyBtn.onclick = () => {
      if (callInput.value) {
        navigator.clipboard.writeText(callInput.value).then(() => {
          copyBtn.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>
            Copied!`;
          setTimeout(() => {
            copyBtn.innerHTML = `
              <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
              Copy ID`;
          }, 2000);
        }).catch(err => {
          console.error("Failed to copy:", err);
          alert("Failed to copy Call ID. Please copy manually.");
        });
      }
    };

    // Hang Up
    hangupBtn.onclick = () => {
      resetCall();
    };

    // Incoming call handling
    acceptBtn.onclick = async () => {
      ringtone.pause();
      incomingCall.style.display = "none";
      await handleAnswerCall(currentCallId);
    };

    rejectBtn.onclick = () => {
      ringtone.pause();
      incomingCall.style.display = "none";
      updateStatus("Call rejected.", "");
      
      // Clean up if we were in the middle of answering
      if (currentCallId) {
        const callDoc = doc(db, "calls", currentCallId);
        // We don't delete the document to allow the caller to see it was rejected
        // But we can update it to show rejection status if needed
      }
      
      resetCall();
    };

    // Handle answering a call (shared function)
    async function handleAnswerCall(callId) {
      currentCallId = callId;
      isCaller = false;
      
      const callDoc = doc(db, "calls", callId);
      const offerCandidates = collection(callDoc, "offerCandidates");
      const answerCandidates = collection(callDoc, "answerCandidates");

      // Set up ICE candidate handling
      pc.onicecandidate = event => {
        if (event.candidate) {
          addDoc(answerCandidates, event.candidate.toJSON());
        }
      };

      try {
        updateStatus("Fetching call details...", "ringing");
        const callSnapshot = await getDoc(callDoc);
        
        if (!callSnapshot.exists()) {
          throw new Error("Call not found. Please check the Call ID.");
        }
        
        const callData = callSnapshot.data();
        if (!callData.offer) {
          throw new Error("Invalid call data. Offer not found.");
        }
        
        // Show caller info
        if (callData.caller) {
          remoteLabel.textContent = callData.caller;
          updateStatus(`Incoming call from ${callData.caller}...`, "ringing");
        } else {
          updateStatus("Incoming call...", "ringing");
        }
        
        // Set remote description (offer)
        const offerDescription = callData.offer;
        await pc.setRemoteDescription(new RTCSessionDescription(offerDescription));

        // Create answer
        const answerDescription = await pc.createAnswer();
        await pc.setLocalDescription(answerDescription);

        // Update call document with answer and callee info
        await updateDoc(callDoc, {
          answer: {
            type: answerDescription.type,
            sdp: answerDescription.sdp,
          },
          callee: username
        });

        // Listen for ICE candidates from caller
        onSnapshot(offerCandidates, snapshot => {
          snapshot.docChanges().forEach(change => {
            if (change.type === "added") {
              const data = change.doc.data();
              pc.addIceCandidate(new RTCIceCandidate(data));
            }
          });
        });
        
        // Listen for updates to the call document (like hangup)
        onSnapshot(callDoc, snapshot => {
          if (!snapshot.exists()) {
            // Call document deleted - call ended
            resetCall();
          }
        });
        
        answerBtn.style.display = "none";
        hangupBtn.style.display = "flex";
        createBtn.disabled = true;
        startBtn.disabled = true;
        
      } catch (error) {
        console.error("Error answering call:", error);
        updateStatus("Error answering call: " + error.message, "");
        resetCall();
        alert(error.message);
      }
    }

    // Listen for incoming calls
    async function setupIncomingCallListener() {
      // In a real app, we'd have a users collection and listen for calls directed to this user
      // For this demo, we'll check calls collection for new calls that don't have a callee yet
      // This is a simplified approach - in production you'd have a better signaling system
      
      // We'll check periodically for new calls that might be for this user
      // This is not efficient but works for the demo without user auth
      setInterval(async () => {
        if (isCaller || pc.connectionState === "connected") return;
        
        const callId = callInput.value.trim();
        if (!callId) return;
        
        try {
          const callDoc = doc(db, "calls", callId);
          const callSnapshot = await getDoc(callDoc);
          
          if (callSnapshot.exists()) {
            const callData = callSnapshot.data();
            // If there's an offer and no answer yet, and we haven't shown the incoming call UI
            if (callData.offer && !callData.answer && !callData.callee && 
                callData.caller && callData.caller !== username &&
                incomingCall.style.display !== "flex") {
              
              // Show incoming call UI
              callerName.textContent = callData.caller;
              incomingCall.style.display = "flex";
              
              // Start ringing
              ringtone.play().catch(e => console.log("Autoplay prevented:", e));
              
              // Auto-reject after 30 seconds
              setTimeout(() => {
                if (incomingCall.style.display === "flex") {
                  ringtone.pause();
                  incomingCall.style.display = "none";
                  updateStatus("Call timed out.", "");
                }
              }, 30000);
            }
          }
        } catch (error) {
          console.error("Error checking for incoming calls:", error);
        }
      }, 2000);
    }

    // Reset call state
    function resetCall() {
      // Close peer connection and create a new one
      if (pc) {
        pc.close();
      }
      pc = new RTCPeerConnection(servers);
      
      // Reattach event handlers to new peer connection
      pc.ontrack = event => {
        event.streams[0].getTracks().forEach(track => {
          if (!remoteStream.getTrackById(track.id)) {
            remoteStream.addTrack(track);
          }
        });
        updateStatus("Connected! Video call in progress...", "connected");
        hangupBtn.style.display = "flex";
        answerBtn.style.display = "none";
        createBtn.disabled = true;
        startBtn.disabled = true;
      };
      
      pc.onconnectionstatechange = () => {
        console.log("Connection state:", pc.connectionState);
        if (pc.connectionState === "connected") {
          updateStatus("Connected! Video call in progress...", "connected");
        } else if (pc.connectionState === "disconnected" || pc.connectionState === "failed") {
          if (pc.connectionState === "failed") {
            pc.restartIce();
          }
          resetCall();
        }
      };
      
      // Clear remote video
      remoteStream.getTracks().forEach(track => track.stop());
      remoteStream = new MediaStream();
      remoteVideo.srcObject = remoteStream;
      
      // Reset UI
      hangupBtn.style.display = "none";
      answerBtn.style.display = "flex";
      createBtn.disabled = false;
      startBtn.disabled = false;
      callIdDisplay.classList.add("hidden");
      
      // Stop ringing if playing
      ringtone.pause();
      incomingCall.style.display = "none";
      
      // Reset status
      if (localStream) {
        updateStatus("Ready to start a new call!", "");
      } else {
        updateStatus("Please start your camera to make or receive calls.", "");
      }
      
      currentCallId = null;
      isCaller = false;
    }

    // Update status bar
    function updateStatus(message, statusClass) {
      statusBar.textContent = message;
      statusBar.className = "status-bar";
      if (statusClass) {
        statusBar.classList.add(statusClass);
      }
    }

    // Initialize
    updateStatus("Please start your camera to make or receive calls.", "");
    createBtn.disabled = true;
    answerBtn.disabled = true;
    
    // Setup incoming call listener
    setupIncomingCallListener();
    
    // Auto-start camera if permissions already granted
    navigator.mediaDevices.enumerateDevices()
      .then(devices => {
        const hasCamera = devices.some(device => device.kind === 'videoinput');
        const hasMic = devices.some(device => device.kind === 'audioinput');
        
        if (hasCamera && hasMic && localStorage.getItem('cameraAutoStart') !== 'false') {
          // Don't auto-start on mobile to avoid annoying users
          if (!/Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
            startBtn.click();
          }
        }
      })
      .catch(err => console.error("Error enumerating devices:", err));
  </script>
</body>
</html>
